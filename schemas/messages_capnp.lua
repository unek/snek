-- Generated by lua-capnproto 0.1.2-1 on Sun Jan 31 11:13:16 2016
-- https://github.com/cloudflare/lua-capnproto.git


local ffi = require "ffi"
local capnp = require "capnp"
local bit = require "bit"

local ceil              = math.ceil
local write_struct_field= capnp.write_struct_field
local read_struct_field = capnp.read_struct_field
local read_text         = capnp.read_text
local write_text        = capnp.write_text
local get_enum_val      = capnp.get_enum_val
local get_enum_name     = capnp.get_enum_name
local get_data_off      = capnp.get_data_off
local write_listp_buf   = capnp.write_listp_buf
local write_structp_buf = capnp.write_structp_buf
local write_structp     = capnp.write_structp
local read_struct_buf   = capnp.read_struct_buf
local read_listp_struct = capnp.read_listp_struct
local read_list_data    = capnp.read_list_data
local write_list        = capnp.write_list
local write_list_data   = capnp.write_list_data
local ffi_new           = ffi.new
local ffi_string        = ffi.string
local ffi_cast          = ffi.cast
local ffi_copy          = ffi.copy
local ffi_fill          = ffi.fill
local ffi_typeof        = ffi.typeof
local band, bor, bxor = bit.band, bit.bor, bit.bxor

local pint8    = ffi_typeof("int8_t *")
local pint16   = ffi_typeof("int16_t *")
local pint32   = ffi_typeof("int32_t *")
local pint64   = ffi_typeof("int64_t *")
local puint8   = ffi_typeof("uint8_t *")
local puint16  = ffi_typeof("uint16_t *")
local puint32  = ffi_typeof("uint32_t *")
local puint64  = ffi_typeof("uint64_t *")
local pbool    = ffi_typeof("uint8_t *")
local pfloat32 = ffi_typeof("float *")
local pfloat64 = ffi_typeof("double *")


local ok, new_tab = pcall(require, "table.new")

if not ok then
    new_tab = function (narr, nrec) return {} end
end

local round8 = function(size)
    return ceil(size / 8) * 8
end

local str_buf
local default_segment_size = 4096

local function get_str_buf(size)
    if size > default_segment_size then
        return ffi_new("char[?]", size)
    end

    if not str_buf then
        str_buf = ffi_new("char[?]", default_segment_size)
    end
    return str_buf
end

-- Estimated from #nodes, not accurate
local _M = new_tab(0, 18)


_M.Message = {
    id = "12203149498718397627",
    displayName = "messages.capnp:Message",
    dataWordCount = 1,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "type", default = "tick", ["type"] = "enum" },
        { name = "compressed", default = 0, ["type"] = "bool" },
        { name = "message", default = "", ["type"] = "data" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        -- data
        value = data["message"]
        if type(value) == "string" then
            size = size + round8(#value)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["type"]
        if type(value) == "string" or type(value) == "number" then
            local val = get_enum_val(value, 0, _M.Message.MessageType, "Message.type")
            write_struct_field(p32, val, "uint16", 16, 0)
        end

        value = data["compressed"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 16, 0)
        end

        value = data["message"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Message, 0, pos)

            local len = #value
            write_listp_buf(p32, _M.Message, 0, 2, len, data_off)

            -- prevent copying trailing '\0'
            ffi_copy(p32 + pos / 4, value, len)
            pos = pos + round8(len)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message, 0)

        -- skip header & struct pointer
        _M.Message.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- enum
        local val = read_struct_field(p32, "uint16", 16, 0)
        s["type"] = get_enum_name(val, 0, _M.Message.MessageTypeStr)

        s["compressed"] = read_struct_field(p32, "bool", 1, 16, 0)

        -- data
        local off, size, num = read_listp_struct(p32, header, _M.Message, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["message"] = ffi_string(p8, num)
        else
            s["message"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.MessageType = {
    ["TICK"] = 0,
    ["HELLO"] = 1,
    ["CHAT"] = 2,
    ["ADD_SNEK"] = 3,
    ["REMOVE_SNEK"] = 4,
    ["RESPAWN"] = 5,
    ["TURN"] = 6,
    ["RESIZE"] = 7,
    ["DIE"] = 8,
    ["STOP"] = 9,

}

_M.Message.MessageTypeStr = {
    [0] = "TICK",
    [1] = "HELLO",
    [2] = "CHAT",
    [3] = "ADD_SNEK",
    [4] = "REMOVE_SNEK",
    [5] = "RESPAWN",
    [6] = "TURN",
    [7] = "RESIZE",
    [8] = "DIE",
    [9] = "STOP",

}

_M.Message.Hello = {
    id = "13178154003816705964",
    displayName = "messages.capnp:Message.Hello",
    dataWordCount = 1,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "version", default = 0, ["type"] = "uint16" },
        { name = "nickname", default = "", ["type"] = "text" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        -- text
        value = data["nickname"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Hello.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["version"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end

        value = data["nickname"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Message.Hello, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Message.Hello, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Hello.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Hello, 0)

        -- skip header & struct pointer
        _M.Message.Hello.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["version"] = read_struct_field(p32, "uint16", 16, 0, 0)

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Message.Hello, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["nickname"] = ffi_string(p8, num - 1)
        else
            s["nickname"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Hello.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Respawn = {
    id = "11051212082126753680",
    displayName = "messages.capnp:Message.Respawn",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "id", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Respawn.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Respawn.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Respawn, 0)

        -- skip header & struct pointer
        _M.Message.Respawn.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["id"] = read_struct_field(p32, "uint16", 16, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Respawn.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Turn = {
    id = "10845366916463043616",
    displayName = "messages.capnp:Message.Turn",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "id", default = 0, ["type"] = "uint16" },
        { name = "direction", default = 0, ["type"] = "uint8" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Turn.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end

        value = data["direction"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 2, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Turn.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Turn, 0)

        -- skip header & struct pointer
        _M.Message.Turn.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["id"] = read_struct_field(p32, "uint16", 16, 0, 0)

        s["direction"] = read_struct_field(p32, "uint8", 8, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Turn.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Resize = {
    id = "16934271477244294482",
    displayName = "messages.capnp:Message.Resize",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "id", default = 0, ["type"] = "uint16" },
        { name = "size", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Resize.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end

        value = data["size"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 1, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Resize.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Resize, 0)

        -- skip header & struct pointer
        _M.Message.Resize.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["id"] = read_struct_field(p32, "uint16", 16, 0, 0)

        s["size"] = read_struct_field(p32, "uint16", 16, 1, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Resize.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Die = {
    id = "16323116051930187258",
    displayName = "messages.capnp:Message.Die",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "id", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Die.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Die.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Die, 0)

        -- skip header & struct pointer
        _M.Message.Die.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["id"] = read_struct_field(p32, "uint16", 16, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Die.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Stop = {
    id = "9310010532156313425",
    displayName = "messages.capnp:Message.Stop",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "id", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Stop.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Stop.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Stop, 0)

        -- skip header & struct pointer
        _M.Message.Stop.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["id"] = read_struct_field(p32, "uint16", 16, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Stop.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Chat = {
    id = "16653321707581922674",
    displayName = "messages.capnp:Message.Chat",
    dataWordCount = 0,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "message", default = "opaque pointer", ["type"] = "struct" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        -- struct
        value = data["message"]
        if type(value) == "table" then
            size = size + _M.Message.Chat.ChatMessage.calc_size_struct(value)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Chat.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["message"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Message.Chat, 0, pos)
            write_structp_buf(p32, _M.Message.Chat, _M.Message.Chat.ChatMessage, 0, data_off)
            local size = _M.Message.Chat.ChatMessage.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Chat.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Chat, 0)

        -- skip header & struct pointer
        _M.Message.Chat.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- struct
        local p = p32 + (0 + 0) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["message"] then
                s["message"] = new_tab(0, 2)
            end
            _M.Message.Chat.ChatMessage.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["message"])
        else
            s["message"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Chat.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Chat.ChatMessage = {
    id = "16256379195831906160",
    displayName = "messages.capnp:Message.Chat.ChatMessage",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "color", default = "opaque pointer", ["type"] = "struct" },
        { name = "text", default = "", ["type"] = "text" },
        { name = "formatting", default = Nil, ["type"] = "group" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- struct
        value = data["color"]
        if type(value) == "table" then
            size = size + _M.Color.calc_size_struct(value)
        end
        -- text
        value = data["text"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- struct
        value = data["formatting"]
        if type(value) == "table" then
            size = size + _M.Message.Chat.ChatMessage.formatting.calc_size_struct(value)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Chat.ChatMessage.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["color"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Message.Chat.ChatMessage, 0, pos)
            write_structp_buf(p32, _M.Message.Chat.ChatMessage, _M.Color, 0, data_off)
            local size = _M.Color.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["text"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Message.Chat.ChatMessage, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Message.Chat.ChatMessage, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["formatting"]
        if type(value) == "table" then
            -- groups are just namespaces, field offsets are set within parent
            -- structs
            pos = pos + _M.Message.Chat.ChatMessage.formatting.flat_serialize(value, p32, pos) - 24
        end

        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Message.Chat.ChatMessage.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Message.Chat.ChatMessage, 0)

        -- skip header & struct pointer
        _M.Message.Chat.ChatMessage.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- struct
        local p = p32 + (1 + 0) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["color"] then
                s["color"] = new_tab(0, 2)
            end
            _M.Color.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["color"])
        else
            s["color"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Message.Chat.ChatMessage, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["text"] = ffi_string(p8, num - 1)
        else
            s["text"] = nil
        end

        -- group
        if not s["formatting"] then
            s["formatting"] = new_tab(0, 4)
        end
        _M.Message.Chat.ChatMessage["formatting"].parse_struct_data(p32, _M.Message.Chat.ChatMessage.dataWordCount,
                _M.Message.Chat.ChatMessage.pointerCount, header, s["formatting"])

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Message.Chat.ChatMessage.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Message.Chat.ChatMessage.formatting = {
    id = "13234805195766623854",
    displayName = "messages.capnp:Message.Chat.ChatMessage.formatting",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    isGroup = true,
    field_count = 4,

    fields = {
        { name = "bold", default = 0, ["type"] = "bool" },
        { name = "underline", default = 0, ["type"] = "bool" },
        { name = "italic", default = 0, ["type"] = "bool" },
        { name = "font_size", default = 0, ["type"] = "uint8" },
    },

    calc_size_struct = function(data)
        local size = 0
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Message.Chat.ChatMessage.formatting.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["bold"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 0, 0)
        end

        value = data["underline"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 1, 0)
        end

        value = data["italic"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 2, 0)
        end

        value = data["font_size"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 1, 0)
        end
        return pos - start + 24
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["bold"] = read_struct_field(p32, "bool", 1, 0, 0)

        s["underline"] = read_struct_field(p32, "bool", 1, 1, 0)

        s["italic"] = read_struct_field(p32, "bool", 1, 2, 0)

        s["font_size"] = read_struct_field(p32, "uint8", 8, 1, 0)

        return s
    end,

}

_M.Color = {
    id = "11763965761163715310",
    displayName = "common.capnp:Color",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "r", default = 0, ["type"] = "uint8" },
        { name = "g", default = 0, ["type"] = "uint8" },
        { name = "b", default = 0, ["type"] = "uint8" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Color.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["r"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 0, 0)
        end

        value = data["g"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 1, 0)
        end

        value = data["b"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 2, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Color.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Color, 0)

        -- skip header & struct pointer
        _M.Color.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["r"] = read_struct_field(p32, "uint8", 8, 0, 0)

        s["g"] = read_struct_field(p32, "uint8", 8, 1, 0)

        s["b"] = read_struct_field(p32, "uint8", 8, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Color.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Snek = {
    id = "17105353903284191059",
    displayName = "snek.capnp:Snek",
    dataWordCount = 2,
    pointerCount = 3,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 11,

    fields = {
        { name = "id", default = 0, ["type"] = "uint16" },
        { name = "name", default = "", ["type"] = "text" },
        { name = "direction", default = 0, ["type"] = "uint8" },
        { name = "next_direction", default = 0, ["type"] = "uint8" },
        { name = "max_length", default = 0, ["type"] = "uint16" },
        { name = "dead", default = 0, ["type"] = "bool" },
        { name = "stopped", default = 0, ["type"] = "bool" },
        { name = "speed", default = 0, ["type"] = "uint8" },
        { name = "last_move", default = 0, ["type"] = "uint8" },
        { name = "blocks", default = "opaque pointer", ["type"] = "list" },
        { name = "color", default = "opaque pointer", ["type"] = "struct" },
    },

    calc_size_struct = function(data)
        local size = 40
        local value
        -- text
        value = data["name"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- list
        if data["blocks"] and type(data["blocks"]) == "table" then
            size = size + 8
            local num2 = #data["blocks"]
            for i2=1, num2 do
                size = size + _M.Snek.Block.calc_size_struct(data["blocks"][i2])
            end
        end
        -- struct
        value = data["color"]
        if type(value) == "table" then
            size = size + _M.Snek.Color.calc_size_struct(value)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Snek.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 40 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["id"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end

        value = data["name"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.Snek, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.Snek, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["direction"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 2, 0)
        end

        value = data["next_direction"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 3, 0)
        end

        value = data["max_length"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 2, 0)
        end

        value = data["dead"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 48, 0)
        end

        value = data["stopped"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 49, 0)
        end

        value = data["speed"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 7, 0)
        end

        value = data["last_move"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 8, 0)
        end

        value = data["blocks"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Snek, 1, pos)
            pos = pos + write_list(p32 + _M.Snek.dataWordCount * 2 + 1 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.Snek.Block)
        end

        value = data["color"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.Snek, 2, pos)
            write_structp_buf(p32, _M.Snek, _M.Snek.Color, 2, data_off)
            local size = _M.Snek.Color.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end
        return pos - start + 40
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Snek.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Snek, 0)

        -- skip header & struct pointer
        _M.Snek.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["id"] = read_struct_field(p32, "uint16", 16, 0, 0)

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.Snek, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (2 + 0 + 1 + off) * 2)
            s["name"] = ffi_string(p8, num - 1)
        else
            s["name"] = nil
        end

        s["direction"] = read_struct_field(p32, "uint8", 8, 2, 0)

        s["next_direction"] = read_struct_field(p32, "uint8", 8, 3, 0)

        s["max_length"] = read_struct_field(p32, "uint16", 16, 2, 0)

        s["dead"] = read_struct_field(p32, "bool", 1, 48, 0)

        s["stopped"] = read_struct_field(p32, "bool", 1, 49, 0)

        s["speed"] = read_struct_field(p32, "uint8", 8, 7, 0)

        s["last_move"] = read_struct_field(p32, "uint8", 8, 8, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.Snek, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["blocks"] = read_list_data(p32 + (2 + 1 + 1 + off) * 2, header,
                    num, "struct", _M.Snek.Block)
        else
            s["blocks"] = nil
        end

        -- struct
        local p = p32 + (2 + 2) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["color"] then
                s["color"] = new_tab(0, 2)
            end
            _M.Snek.Color.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["color"])
        else
            s["color"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Snek.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Snek.Color = {
    id = "16591707288213842732",
    displayName = "snek.capnp:Snek.Color",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "r", default = 0, ["type"] = "uint8" },
        { name = "g", default = 0, ["type"] = "uint8" },
        { name = "b", default = 0, ["type"] = "uint8" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Snek.Color.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["r"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 0, 0)
        end

        value = data["g"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 1, 0)
        end

        value = data["b"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint8", 8, 2, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Snek.Color.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Snek.Color, 0)

        -- skip header & struct pointer
        _M.Snek.Color.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["r"] = read_struct_field(p32, "uint8", 8, 0, 0)

        s["g"] = read_struct_field(p32, "uint8", 8, 1, 0)

        s["b"] = read_struct_field(p32, "uint8", 8, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Snek.Color.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.Snek.Block = {
    id = "16319667821592645205",
    displayName = "snek.capnp:Snek.Block",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "x", default = 0, ["type"] = "int16" },
        { name = "y", default = 0, ["type"] = "int16" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.Snek.Block.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["x"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int16", 16, 0, 0)
        end

        value = data["y"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int16", 16, 1, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.Snek.Block.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.Snek.Block, 0)

        -- skip header & struct pointer
        _M.Snek.Block.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["x"] = read_struct_field(p32, "int16", 16, 0, 0)

        s["y"] = read_struct_field(p32, "int16", 16, 1, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.Snek.Block.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

return _M
